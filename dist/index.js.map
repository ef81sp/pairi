{"version":3,"sources":["../src/副露.mts","../src/牌.mts","../src/手牌utils/utils/const.mts","../src/手牌utils/utils/countRequiredブロックnum.mts","../src/手牌utils/utils/count牌.mts","../src/手牌utils/utils/is暗刻.mts","../src/手牌utils/seek有効牌.mts","../src/手牌utils/calcシャンテン数.mts","../src/手牌utils/extractSingleブロック.mts","../src/手牌utils/extractブロックTree.mts","../src/手牌utils/extractPriority雀頭.mts","../src/手牌utils/extractPriority面子.mts","../src/手牌utils/extract特殊役.mts","../src/手牌utils/utils/countRemaining牌.mts","../src/手牌utils/utils/format牌List.mts","../src/手牌utils/analyze手牌.mts","../src/手牌.mts"],"sourcesContent":["import { 牌 } from \"./牌.mjs\"\n\ntype T宣言 = \"ポン\" | \"チー\" | \"大明槓\" | \"加槓\" | \"暗槓\"\ntype T誰から = \"上家\" | \"対面\" | \"下家\"\ntype 副露InputDataポンチー = {\n  call: \"ポン\" | \"チー\"\n  called牌: 牌\n  other牌: [牌, 牌]\n  from: T誰から\n}\ntype 副露InputDataカン = {\n  call: \"大明槓\" | \"加槓\" | \"暗槓\"\n  called牌: 牌\n  other牌: [牌, 牌, 牌]\n  from: T誰から\n}\n\n/**\n * Represents a 副露 (Furo) in a Japanese Mahjong game.\n */\nexport class 副露 {\n  /** The declaration type of the 副露. */\n  readonly call: T宣言\n  /** The tile that was melded. */\n  readonly called牌: 牌\n  /** The other tiles involved in the meld. */\n  readonly other牌: [牌, 牌, 牌?]\n  /** The player from whom the meld was declared. */\n  readonly from: T誰から\n\n  /**\n   * Creates a new instance of the 副露 class.\n   * @param 宣言 The declaration type of the 副露.\n   * @param 鳴いた牌 The tile that was melded.\n   * @param ほかの牌 The other tiles involved in the meld.\n   * @param 誰から The player from whom the meld was declared.\n   */\n  constructor({ call, called牌, other牌, from }: 副露InputDataポンチー | 副露InputDataカン) {\n    this.call = call\n    this.called牌 = called牌\n    this.other牌 = other牌\n    this.from = from\n  }\n\n  /**\n   * Converts the 副露 to a list of tiles.\n   * @returns An array of tiles involved in the meld.\n   */\n  to牌List() {\n    if (this.other牌[2]) {\n      return [this.called牌, this.other牌[0], this.other牌[1], this.other牌[2]]\n    }\n    return [this.called牌, this.other牌[0], this.other牌[1]]\n  }\n}\n","import { Number字牌, Number数牌, Str牌, Suit, Suit字牌, Suit数牌 } from \"./utils/types.mjs\"\n\n/**\n * Represents a 牌 (Mahjong tile).\n */\nexport class 牌 {\n  readonly suit: Suit\n  readonly number: typeof this.suit extends Suit字牌 ? Number字牌 : Number数牌\n  readonly is赤牌: boolean\n  private readonly str牌: Str牌\n\n  /**\n   * Constructs a new 牌 instance.\n   * @param pai - The string representation of the 牌.\n   * @param isRed - Indicates whether the 牌 is a red tile.\n   */\n  constructor(pai: Str牌, isRed = false) {\n    const { suit, number } = parsePaiString(pai)\n    this.suit = suit\n    this.number = number\n    this.is赤牌 = (() => {\n      if (suit === \"z\") return false\n      return number === 5 && isRed\n    })()\n    this.str牌 = pai\n  }\n\n  /**\n   * Returns the string representation of the 牌.\n   * @returns The string representation of the 牌.\n   */\n  toString() {\n    return this.str牌\n  }\n\n  /**\n   * Checks if the 牌 is equal to another 牌.\n   * @param pai - The 牌 to compare.\n   * @returns `true` if the 牌 is equal to the specified 牌, `false` otherwise.\n   */\n  toEqual(pai: 牌) {\n    return this.str牌 === pai.str牌\n  }\n\n  /**\n   * Creates a clone of the 牌.\n   * @returns A new 牌 instance that is a clone of the current 牌.\n   */\n  clone() {\n    return new 牌(this.str牌, this.is赤牌)\n  }\n}\n\n/**\n * Parses a string representation of a 牌 and returns the corresponding suit and number.\n * @param pai - The string representation of the 牌.\n * @returns An object containing the suit and number of the 牌.\n * @throws Error if the string representation is invalid.\n */\nconst parsePaiString = (\n  pai: string,\n): { suit: Suit数牌; number: Number数牌 } | { suit: Suit字牌; number: Number字牌 } => {\n  if (pai.length !== 2) throw new Error(`invalid signature ${pai}: length must be 2.`)\n\n  const number = Number(pai[0])\n  const suit = pai[1]\n  const numberErrorMessage = `invalid signature ${pai}: number must be 1, 2, 3, 4, 5, 6, 7, 8 or 9.`\n  const numberErrorMessage数牌 = `invalid signature ${pai}: number must be 1, 2, 3, 4, 5, 6, 7, 8 or 9.`\n  const numberErrorMessage字牌 = `invalid signature ${pai}: number must be 1, 2, 3, 4, 5, 6 or 7.`\n\n  if (!Number.isInteger(number)) throw new Error(numberErrorMessage)\n  if (suit === undefined || ![\"m\", \"p\", \"s\", \"z\"].includes(suit))\n    throw new Error(`invalid signature ${pai}: suit must be \"m\", \"p\", \"s\" or \"z\".`)\n\n  if ([\"m\", \"p\", \"s\"].includes(suit)) {\n    if (!(1 <= number && number <= 9)) throw new Error(numberErrorMessage数牌)\n    return {\n      suit,\n      number,\n    } as { suit: Suit数牌; number: Number数牌 }\n  }\n  if (!(1 <= number && number <= 7)) throw new Error(numberErrorMessage字牌)\n  return {\n    suit,\n    number,\n  } as { suit: Suit字牌; number: Number字牌 }\n}\n\n/**\n * Checks if a string is a valid 牌.\n * @param str - The string to check.\n * @returns `true` if the string is a valid 牌, `false` otherwise.\n */\nexport const isStr牌 = (str: string): str is Str牌 => {\n  if (str.length !== 2) return false\n  const number = Number(str[0])\n  const suit = str[1]\n  if (!Number.isInteger(number)) return false\n  if (suit === undefined) return false\n  if (![\"m\", \"p\", \"s\", \"z\"].includes(suit)) return false\n  if ([\"m\", \"p\", \"s\"].includes(suit)) {\n    if (!(1 <= number && number <= 9)) return false\n  } else {\n    if (!(1 <= number && number <= 7)) return false\n  }\n  return true\n}\n","import { 牌 } from \"../../牌.mjs\"\n\n// biome-ignore format: みやすい\nexport const whole牌List: readonly 牌[] =[\n  new 牌(\"1m\"),  new 牌(\"2m\"),  new 牌(\"3m\"),  new 牌(\"4m\"),  new 牌(\"5m\"),  new 牌(\"6m\"),  new 牌(\"7m\"),  new 牌(\"8m\"),  new 牌(\"9m\"),\n  new 牌(\"1p\"),  new 牌(\"2p\"),  new 牌(\"3p\"),  new 牌(\"4p\"),  new 牌(\"5p\"),  new 牌(\"6p\"),  new 牌(\"7p\"),  new 牌(\"8p\"),  new 牌(\"9p\"),\n  new 牌(\"1s\"),  new 牌(\"2s\"),  new 牌(\"3s\"),  new 牌(\"4s\"),  new 牌(\"5s\"),  new 牌(\"6s\"),  new 牌(\"7s\"),  new 牌(\"8s\"),  new 牌(\"9s\"),\n  new 牌(\"1z\"),  new 牌(\"2z\"),  new 牌(\"3z\"),  new 牌(\"4z\"),  new 牌(\"5z\"),  new 牌(\"6z\"),  new 牌(\"7z\"),\n]\n","export const countRequiredブロックnum = (count牌: number): number => {\n  switch (count牌) {\n    case 1:\n      return 1\n    case 4:\n      return 2\n    case 7:\n      return 3\n    case 10:\n      return 4\n    case 13:\n      return 5\n    default:\n      throw new Error(`invalid count牌: ${count牌}`)\n  }\n}\n","import { flattenRest } from \"../seek有効牌.mjs\"\nimport { ExtractResult5ブロック } from \"../手牌utils.type.mjs\"\n\nexport const count牌 = (extractResult5ブロック: ExtractResult5ブロック): number => {\n  let count = 0\n  if (extractResult5ブロック.雀頭) count += 2\n  count += extractResult5ブロック.面子.length * 3\n  count += extractResult5ブロック.塔子.length * 2\n  count += flattenRest(extractResult5ブロック.rest).length\n  return count\n}\n","import { T面子 } from \"../手牌utils.type.mjs\"\n\nexport const is暗刻 = (面子: T面子): boolean => {\n  return (\n    面子.component[0].toEqual(面子.component[1]) && 面子.component[0].toEqual(面子.component[2])\n  )\n}\n","import { isStr牌, 牌 } from \"../牌.mjs\"\nimport { whole牌List } from \"./utils/const.mjs\"\nimport { countRequiredブロックnum } from \"./utils/countRequiredブロックnum.mjs\"\nimport { count牌 } from \"./utils/count牌.mjs\"\nimport { is暗刻 } from \"./utils/is暗刻.mjs\"\nimport {\n  ExtractResult5ブロック,\n  ExtractResult七対子,\n  ExtractResult国士無双,\n  T塔子,\n  T手牌Suit別,\n  T雀頭,\n  T面子,\n} from \"./手牌utils.type.mjs\"\n\nexport const seek有効牌5ブロック = (\n  extractResult: ExtractResult5ブロック,\n  シャンテン数: number,\n): 牌[] => {\n  if (シャンテン数 === 0) return seek有効牌5ブロックテンパイ(extractResult)\n  return seek有効牌5ブロックノーテン(extractResult)\n}\n\nexport const seek有効牌七対子 = (extractResult: ExtractResult七対子): 牌[] => {\n  const result: 牌[] = []\n  for (const rest of flattenRest(extractResult.rest)) {\n    // 対子で使われている場合はskip\n    if (extractResult.対子.some((対子) => 対子.component.some((p) => p.toEqual(rest)))) continue\n    result.push(rest.clone())\n  }\n  return result\n}\n\nexport const seek有効牌国士無双 = (extractResult: ExtractResult国士無双): 牌[] => {\n  const target = (\n    [\"1m\", \"9m\", \"1p\", \"9p\", \"1s\", \"9s\", \"1z\", \"2z\", \"3z\", \"4z\", \"5z\", \"6z\", \"7z\"] as const\n  ).map((s) => new 牌(s))\n\n  // 么九牌restが空(=雀頭がない)なら、すべての么九牌\n  if (extractResult.么九牌rest.length === 0) return target\n\n  // そうでない(雀頭がある)なら、么九牌uniqueに存在しないもの\n  return target.filter((p) => !extractResult.么九牌unique.some((p2) => p2.toEqual(p)))\n}\nconst seek有効牌5ブロックテンパイ = (extractResult: ExtractResult5ブロック): 牌[] => {\n  if (extractResult.塔子.length >= 2) {\n    throw new Error(\"塔子が2個以上ある場合は聴牌ではない\")\n  }\n  if (extractResult.雀頭) {\n    // 塔子が面子になる牌を求める\n    if (extractResult.塔子[0] === undefined)\n      throw new Error(\"雀頭があって塔子がない場合はテンパイではない\")\n    return seek塔子To面子(extractResult.塔子[0])\n  }\n  // 単騎待ち\n  // restの中にひとつだけある牌を抽出する\n  const rest = flattenRest(extractResult.rest)[0]\n  if (rest === undefined) throw new Error(`invalid rest: ${extractResult.rest}`)\n  const 牌str = rest.toString()\n  return [new 牌(牌str)]\n}\n\nconst seek有効牌5ブロックノーテン = (extractResult: ExtractResult5ブロック): 牌[] => {\n  const result: 牌[] = []\n\n  const required面子塔子num = countRequiredブロックnum(count牌(extractResult)) - 1 // 雀頭は除く\n  const 面子塔子数 = extractResult.面子.length + extractResult.塔子.length\n\n  for (const 塔子 of extractResult.塔子) {\n    result.push(...seek塔子To面子(塔子))\n  }\n\n  // 雀頭以外のブロックが足りない場合のみ、①restが塔子になる牌 ②雀頭の牌 が有効牌になる\n  const restList = flattenRest(extractResult.rest)\n  if (面子塔子数 < required面子塔子num) {\n    for (const rest of restList) {\n      result.push(...seekRestTo塔子(rest, extractResult.雀頭, extractResult.面子))\n    }\n    // 浮き牌に同じ牌がない場合のみ、雀頭が有効牌になる\n    if (extractResult.雀頭 && !restList.some((p) => extractResult.雀頭?.component[0].toEqual(p))) {\n      result.push(extractResult.雀頭.component[0].clone())\n    }\n  }\n\n  if (!extractResult.雀頭) {\n    const 暗刻List = extract暗刻List(extractResult.面子)\n    // 雀頭がなく、雀頭以外のブロックが足りている場合、\n    if (面子塔子数 === required面子塔子num) {\n      // restは雀頭にならないといけない\n      // restに暗刻で使われている牌しかない場合、それは雀頭になれない。その場合、暗刻で使われている牌以外すべてが有効牌になる\n      if (restList.every((p) => isSameAs雀頭Or暗刻(p, null, extractResult.面子))) {\n        result.push(\n          ...whole牌List.filter((p) => 暗刻List.every((暗刻) => !暗刻.component[0].toEqual(p))),\n        )\n      } else {\n        result.push(\n          ...restList.filter((r) => !isSameAs雀頭Or暗刻(r, extractResult.雀頭, extractResult.面子)),\n        )\n      }\n    } else if (面子塔子数 > required面子塔子num) {\n      // 雀頭がなくブロックオーバーの場合は、塔子が雀頭になる ただし、暗刻で使われている牌は除く\n      for (const 塔子 of extractResult.塔子) {\n        result.push(\n          ...塔子.component\n            .filter((p) => 暗刻List.every((暗刻) => !暗刻.component[0].toEqual(p)))\n            .map((p) => p.clone()),\n        )\n      }\n    }\n  }\n\n  const uniqueResult = result\n    .filter((p, i) => {\n      return result.findIndex((p2) => p2.toEqual(p)) === i\n    })\n    .sort((a, b) => {\n      if (a.suit === b.suit) return a.number - b.number\n      return a.suit.charCodeAt(0) - b.suit.charCodeAt(0)\n    })\n\n  return uniqueResult\n}\n\nexport const flattenRest = (rest: T手牌Suit別): 牌[] => {\n  return Object.values(rest).flat()\n}\n\nconst seek塔子To面子 = (塔子: T塔子): 牌[] => {\n  const [牌1, 牌2] = 塔子.component\n\n  switch (true) {\n    // シャンポン (字牌はここにしか来ない)\n    case 牌1.number === 牌2.number: {\n      return [牌1.clone()]\n    }\n    // 辺張\n    case 牌1.number === 1 && 牌2.number === 2: {\n      return [new 牌(`3${牌1.suit}`)]\n    }\n    case 牌1.number === 8 && 牌2.number === 9: {\n      return [new 牌(`7${牌1.suit}`)]\n    }\n    // 嵌張\n    case 牌1.number === 牌2.number - 2: {\n      const 牌str = `${牌1.number + 1}${牌1.suit}`\n      if (!isStr牌(牌str)) throw new Error(`invalid 牌str: ${牌str}`)\n      return [new 牌(牌str)]\n    }\n    // 両面 (辺張は先に弾いてるのでこれでよい)\n    case 牌1.number === 牌2.number - 1: {\n      const 牌str1 = `${牌1.number - 1}${牌1.suit}`\n      const 牌str2 = `${牌2.number + 1}${牌2.suit}`\n      if (!isStr牌(牌str1)) throw new Error(`invalid 牌str: ${牌str1}`)\n      if (!isStr牌(牌str2)) throw new Error(`invalid 牌str: ${牌str2}`)\n      return [new 牌(牌str1), new 牌(牌str2)]\n    }\n    default: {\n      throw new Error(\n        `invalid 塔子: ${塔子.component[0].toString()} ${塔子.component[1].toString()}`,\n      )\n    }\n  }\n}\n\nconst seekRestTo塔子 = (浮き牌: 牌, 雀頭: T雀頭 | null, 面子List: T面子[]): 牌[] => {\n  const n = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n  const 暗刻List = extract暗刻List(面子List)\n  switch (浮き牌.suit) {\n    // m, p, s なら、2つとなりまでの牌\n    case \"m\":\n    case \"p\":\n    case \"s\": {\n      const index = n.indexOf(浮き牌.number)\n      const min = Math.max(0, index - 2)\n      const max = Math.min(8, index + 2)\n      const targetNum = n.slice(min, max + 1)\n\n      return targetNum\n        .map((n) => {\n          const str = `${n}${浮き牌.suit}`\n          if (!isStr牌(str)) throw new Error(`invalid str: ${str}`)\n          return new 牌(str)\n        })\n        .filter((p) => {\n          // 浮き牌が雀頭や暗刻と同じ牌の場合、浮き牌と同じ牌ではテンパイしないので、除外\n          return !(p.toEqual(浮き牌) && isSameAs雀頭Or暗刻(p, 雀頭, 暗刻List))\n        })\n    }\n    // z なら、同じ牌\n    case \"z\": {\n      return isSameAs雀頭Or暗刻(浮き牌, 雀頭, 暗刻List) ? [] : [浮き牌.clone()]\n    }\n  }\n}\n\nfunction isSameAs雀頭Or暗刻(浮き牌: 牌, 雀頭: T雀頭 | null, 面子List: T面子[]) {\n  if (雀頭?.component[0].toEqual(浮き牌)) return true\n  if (面子List.filter((m) => is暗刻(m)).some((暗刻) => 暗刻.component[0].toEqual(浮き牌)))\n    return true\n  return false\n}\n\nfunction extract暗刻List(面子List: T面子[]) {\n  return 面子List.filter((m) => is暗刻(m))\n}\n","import { flattenRest } from \"./seek有効牌.mjs\"\nimport { countRequiredブロックnum } from \"./utils/countRequiredブロックnum.mjs\"\nimport { count牌 } from \"./utils/count牌.mjs\"\nimport { is暗刻 } from \"./utils/is暗刻.mjs\"\nimport {\n  ExtractResult5ブロック,\n  ExtractResult七対子,\n  ExtractResult国士無双,\n} from \"./手牌utils.type.mjs\"\n\nexport const calcシャンテン数5ブロック = (\n  extractResult5ブロック: ExtractResult5ブロック,\n): number => {\n  const requiredブロックnum = countRequiredブロックnum(count牌(extractResult5ブロック))\n\n  const required面子num = requiredブロックnum - 1\n  const { 雀頭, 面子, 塔子, rest: _rest } = extractResult5ブロック\n  const rest = flattenRest(_rest)\n\n  // いわゆる「8点法」を採用\n  let シャンテン数 = 8\n\n  // 手牌が短い場合、必要面子数が減る\n  シャンテン数 -= (5 - requiredブロックnum) * 2\n\n  // 面子の数 * 2点\n  シャンテン数 -= 面子.length * 2\n  // 塔子の数 * 1点\n  シャンテン数 -= 塔子.length\n  // 雀頭があれば 1点\n  シャンテン数 -= 雀頭 ? 1 : 0\n\n  // 例外パターン\n  // 面子と塔子が5個以上あると +1点 (雀頭は関係ない)\n  if (面子.length + 塔子.length >= requiredブロックnum) {\n    シャンテン数 += 1\n  }\n  // 雀頭と塔子が同一だと +1点\n  if (\n    雀頭 &&\n    塔子.some(\n      (塔子) =>\n        塔子.component[0].toEqual(塔子.component[1]) &&\n        塔子.component[0].toEqual(雀頭.component[0]),\n    )\n  ) {\n    シャンテン数 += 1\n  }\n  // 単騎待ちの牌が暗刻で使われていると +1点\n  if (!雀頭 && 面子.length === required面子num && rest.length === 1) {\n    const tanki = rest[0]\n    if (tanki && 面子.some((面子) => is暗刻(面子) && 面子.component[0].toEqual(tanki))) {\n      シャンテン数 += 1\n    }\n  }\n  return シャンテン数\n}\nexport const calcシャンテン数七対子 = (extractResult七対子: ExtractResult七対子): number => {\n  let result = 6 - extractResult七対子.対子.length\n\n  // restに対子に含まれる牌がある場合は、その種類の数だけシャンテン数が増える\n  const uniqueFlattenRest = flattenRest(extractResult七対子.rest).filter(\n    (p, index, array) => array.findIndex((p2) => p2.toString() === p.toString()) === index,\n  )\n  for (const rest of uniqueFlattenRest) {\n    if (extractResult七対子.対子.some((対子) => 対子.component[0].toEqual(rest))) {\n      result += 1\n    }\n  }\n\n  return result\n}\n\nexport const calcシャンテン数国士無双 = (extractResult国士無双: ExtractResult国士無双): number => {\n  return extractResult国士無双.么九牌rest.length === 0\n    ? 13 - extractResult国士無双.么九牌unique.length\n    : 12 - extractResult国士無双.么九牌unique.length\n}\n","import { Suit } from \"../utils/types.mjs\"\nimport { isStr牌, 牌 } from \"../牌.mjs\"\nimport {\n  Result単体抽出,\n  Result単体抽出Success,\n  Tブロック,\n  TブロックType,\n  T塔子,\n  T対子,\n  T手牌Suit別,\n  T雀頭,\n  T面子,\n} from \"./手牌utils.type.mjs\"\n\n// 用語: 順塔子とは、 両面・辺張・嵌張 のこと。一般名称がないので……\n\n// TS、返り値の型の絞り込みは未実装らしい。asで型アサーションするしかない。\n\nexport const extractSingleブロック = <T extends TブロックType>(\n  手牌: T手牌Suit別,\n  type: T,\n  startAt: { suit: Suit; index: number },\n): Result単体抽出<T> => {\n  validate手牌(手牌)\n\n  const { suit, index } = startAt\n  switch (type) {\n    case \"雀頭\": {\n      const 牌1 = 手牌[suit][index]\n      const 牌2 = 手牌[suit][index + 1]\n      if (!(牌1 && 牌2)) return { status: \"failure\" }\n      if (!is対子(牌1, 牌2)) return { status: \"failure\" }\n      const ブロック: T雀頭 = {\n        type: \"雀頭\",\n        component: [牌1, 牌2],\n      }\n      const result: Result単体抽出<\"雀頭\"> = {\n        status: \"success\",\n        ブロック,\n        rest: {\n          ...手牌,\n          [suit]: 手牌[suit].filter((_, i) => i !== index && i !== index + 1),\n        },\n      }\n      return result satisfies Result単体抽出Success<\"雀頭\"> as Result単体抽出<T>\n    }\n    case \"面子\": {\n      // 刻子 → 順子\n      const 牌1 = 手牌[suit][index]\n      const 牌2 = 手牌[suit][index + 1]\n      const 牌3 = 手牌[suit][index + 2]\n      if (!(牌1 && 牌2 && 牌3)) return { status: \"failure\" }\n      if (is刻子(牌1, 牌2, 牌3)) {\n        const ブロック: T面子 = {\n          type: \"面子\",\n          component: [牌1, 牌2, 牌3],\n        }\n        const result: Result単体抽出<\"面子\"> = {\n          status: \"success\",\n          ブロック,\n          rest: {\n            ...手牌,\n            [suit]: 手牌[suit].filter((_, i) => i !== index && i !== index + 1 && i !== index + 2),\n          },\n        }\n        return result satisfies Result単体抽出Success<\"面子\"> as Result単体抽出<T>\n      }\n      return find順子(手牌, startAt) as Result単体抽出<T>\n    }\n    case \"塔子\": {\n      // 対子 → 順塔子\n      const 牌1 = 手牌[suit][index]\n      const 牌2 = 手牌[suit][index + 1]\n      if (!(牌1 && 牌2)) return { status: \"failure\" }\n      if (is対子(牌1, 牌2)) {\n        const ブロック: T塔子 = {\n          type: \"塔子\",\n          component: [牌1, 牌2],\n        }\n        const result: Result単体抽出<\"塔子\"> = {\n          status: \"success\",\n          ブロック,\n          rest: {\n            ...手牌,\n            [suit]: 手牌[suit].filter((_, i) => i !== index && i !== index + 1),\n          },\n        }\n        return result satisfies Result単体抽出Success<\"塔子\"> as Result単体抽出<T>\n      }\n      return find順塔子(手牌, startAt) as Result単体抽出<T>\n    }\n    case \"対子\": {\n      // 雀頭と同じだが七対子用として分ける\n      const 牌1 = 手牌[suit][index]\n      const 牌2 = 手牌[suit][index + 1]\n      if (!(牌1 && 牌2)) return { status: \"failure\" }\n      if (!is対子(牌1, 牌2)) return { status: \"failure\" }\n      const ブロック: T対子 = {\n        type: \"対子\",\n        component: [牌1, 牌2],\n      }\n      const result: Result単体抽出<\"対子\"> = {\n        status: \"success\",\n        ブロック,\n        rest: {\n          ...手牌,\n          [suit]: 手牌[suit].filter((_, i) => i !== index && i !== index + 1),\n        },\n      }\n      return result satisfies Result単体抽出Success<\"対子\"> as Result単体抽出<T>\n    }\n    default:\n      throw new Error(`invalid type: ${type}`)\n  }\n}\n\nconst validate手牌 = (手牌: T手牌Suit別): void => {\n  if (!手牌.m.every((p) => p.suit === \"m\")) {\n    throw new Error(`invalid type in \"手牌.m\". received: ${手牌.m.map((p) => p.toString()).join()}`)\n  }\n  if (!手牌.p.every((p) => p.suit === \"p\")) {\n    throw new Error(`invalid type in \"手牌.p\". received: ${手牌.p.map((p) => p.toString()).join()}`)\n  }\n  if (!手牌.s.every((p) => p.suit === \"s\")) {\n    throw new Error(`invalid type in \"手牌.s\". received: ${手牌.s.map((p) => p.toString()).join()}`)\n  }\n  if (!手牌.z.every((p) => p.suit === \"z\")) {\n    throw new Error(`invalid type in \"手牌.z\". received: ${手牌.z.map((p) => p.toString()).join()}`)\n  }\n  if (!手牌.m.every((p) => p.number >= 1 && p.number <= 9)) {\n    throw new Error(\n      `invalid number in \"手牌.m\". received: ${手牌.m.map((p) => p.toString()).join()}`,\n    )\n  }\n  if (!手牌.p.every((p) => p.number >= 1 && p.number <= 9)) {\n    throw new Error(\n      `invalid number in \"手牌.p\". received: ${手牌.p.map((p) => p.toString()).join()}`,\n    )\n  }\n  if (!手牌.s.every((p) => p.number >= 1 && p.number <= 9)) {\n    throw new Error(\n      `invalid number in \"手牌.s\". received: ${手牌.s.map((p) => p.toString()).join()}`,\n    )\n  }\n  if (!手牌.z.every((p) => p.number >= 1 && p.number <= 7)) {\n    throw new Error(\n      `invalid number in \"手牌.z\". received: ${手牌.z.map((p) => p.toString()).join()}`,\n    )\n  }\n}\n\nconst is対子 = (牌1: 牌, 牌2: 牌): boolean => {\n  return 牌1.toEqual(牌2)\n}\n\nconst is刻子 = (牌1: 牌, 牌2: 牌, 牌3: 牌): boolean => {\n  return (\n    牌1.suit === 牌2.suit &&\n    牌2.suit === 牌3.suit &&\n    牌1.number === 牌2.number &&\n    牌2.number === 牌3.number\n  )\n}\n\nconst is順塔子 = (牌1: 牌, 牌2: 牌): boolean => {\n  return 牌1.suit === 牌2.suit && 牌1.number + 1 === 牌2.number\n}\n\nconst find順子 = (\n  手牌: T手牌Suit別,\n  startAt: { suit: Suit; index: number },\n): Result単体抽出<\"面子\"> => {\n  const 手牌suit = 手牌[startAt.suit]\n  const start牌 = 手牌suit[startAt.index]\n\n  if (start牌 === undefined) return { status: \"failure\" }\n  if (start牌.suit === \"z\") return { status: \"failure\" }\n\n  // 8や9から順子は作れない\n  if (start牌.number === 8 || start牌.number === 9) return { status: \"failure\" }\n\n  const 牌2str = `${start牌.number + 1}${start牌.suit}`\n  const 牌3str = `${start牌.number + 2}${start牌.suit}`\n\n  if (!(isStr牌(牌2str) && isStr牌(牌3str))) return { status: \"failure\" }\n\n  const 順子: T面子 = {\n    type: \"面子\",\n    component: [start牌, new 牌(牌2str), new 牌(牌3str)],\n  }\n\n  const 牌2index = 手牌suit.findIndex((p) => p.toString() === 牌2str)\n  const 牌3index = 手牌suit.findIndex((p) => p.toString() === 牌3str)\n\n  if (牌2index === -1 || 牌3index === -1) return { status: \"failure\" }\n  return {\n    status: \"success\",\n    ブロック: 順子,\n    rest: {\n      ...手牌,\n      [startAt.suit]: 手牌suit.filter(\n        (_, i) => i !== startAt.index && i !== 牌2index && i !== 牌3index,\n      ),\n    },\n  }\n}\n\nconst find順塔子 = (\n  手牌: T手牌Suit別,\n  startAt: { suit: Suit; index: number },\n): Result単体抽出<\"塔子\"> => {\n  const 手牌suit = 手牌[startAt.suit]\n  const start牌 = 手牌suit[startAt.index]\n\n  if (start牌 === undefined) return { status: \"failure\" }\n  if (start牌.suit === \"z\") return { status: \"failure\" }\n\n  // 9から順塔子は作れない\n  if (start牌.number === 9) return { status: \"failure\" }\n\n  // 両面・辺張(連続)を試行\n  const 牌2str = `${start牌.number + 1}${start牌.suit}`\n  if (!isStr牌(牌2str)) return { status: \"failure\" }\n\n  const 牌2index = 手牌suit.findIndex((p) => p.toString() === 牌2str)\n  if (牌2index >= 0) {\n    const 塔子: T塔子 = {\n      type: \"塔子\",\n      component: [start牌, new 牌(牌2str)],\n    }\n    return {\n      status: \"success\",\n      ブロック: 塔子,\n      rest: {\n        ...手牌,\n        [startAt.suit]: 手牌suit.filter((_, i) => i !== startAt.index && i !== 牌2index),\n      },\n    }\n  }\n\n  // 嵌張(1個とばし)を試行\n  const 牌3str = `${start牌.number + 2}${start牌.suit}`\n  if (!isStr牌(牌3str)) return { status: \"failure\" }\n\n  const 牌3index = 手牌suit.findIndex((p) => p.toString() === 牌3str)\n  if (牌3index >= 0) {\n    const 塔子: T塔子 = {\n      type: \"塔子\",\n      component: [start牌, new 牌(牌3str)],\n    }\n    return {\n      status: \"success\",\n      ブロック: 塔子,\n      rest: {\n        ...手牌,\n        [startAt.suit]: 手牌suit.filter((_, i) => i !== startAt.index && i !== 牌3index),\n      },\n    }\n  }\n  return { status: \"failure\" }\n}\n","import { extractSingleブロック } from \"./extractSingleブロック.mjs\"\nimport {\n  IntermediateExtractResult,\n  IntermediateExtractTree,\n  TブロックType,\n  T手牌Suit別,\n  T面子,\n} from \"./手牌utils.type.mjs\"\n\nexport const extract面子Tree = (手牌: T手牌Suit別): IntermediateExtractTree<\"面子\">[] => {\n  const wholeResult: ReturnType<typeof extract面子Tree> = []\n  for (const suit of [\"m\", \"p\", \"s\", \"z\"] as const) {\n    const 手牌suit = 手牌[suit]\n    for (let i = 0; i < 手牌suit.length; i++) {\n      const result面子 = extractSingleブロック(手牌, \"面子\", { suit: suit, index: i })\n      if (result面子.status === \"failure\") continue\n\n      const children = extract面子Tree(result面子.rest)\n\n      wholeResult.push({\n        ブロック: result面子.ブロック,\n        rest: result面子.rest,\n        children,\n      })\n    }\n  }\n\n  return wholeResult\n}\n\nexport const extract塔子Tree = (手牌: T手牌Suit別): IntermediateExtractTree<\"塔子\">[] => {\n  const wholeResult: ReturnType<typeof extract塔子Tree> = []\n  for (const suit of [\"m\", \"p\", \"s\", \"z\"] as const) {\n    const 手牌suit = 手牌[suit]\n    for (let i = 0; i < 手牌suit.length; i++) {\n      const result塔子 = extractSingleブロック(手牌, \"塔子\", { suit: suit, index: i })\n      if (result塔子.status === \"failure\") {\n        continue\n      }\n\n      const children = extract塔子Tree(result塔子.rest)\n\n      wholeResult.push({\n        ブロック: result塔子.ブロック,\n        rest: result塔子.rest,\n        children,\n      })\n    }\n  }\n\n  // 塔子がない場合も、restを返さないといけない\n  if (wholeResult.length === 0) {\n    return [\n      {\n        ブロック: null,\n        rest: 手牌,\n        children: [],\n      },\n    ]\n  }\n\n  return wholeResult\n}\n\nexport const extract対子Tree = (手牌: T手牌Suit別): IntermediateExtractTree<\"対子\">[] => {\n  const wholeResult: ReturnType<typeof extract対子Tree> = []\n  for (const suit of [\"m\", \"p\", \"s\", \"z\"] as const) {\n    const 手牌suit = 手牌[suit]\n    for (let i = 0; i < 手牌suit.length; i++) {\n      const result対子 = extractSingleブロック(手牌, \"対子\", { suit: suit, index: i })\n      if (result対子.status === \"failure\") {\n        continue\n      }\n\n      const children = extract対子Tree(result対子.rest)\n\n      wholeResult.push({\n        ブロック: result対子.ブロック,\n        rest: result対子.rest,\n        children,\n      })\n    }\n  }\n\n  // 塔子がない場合も、restを返さないといけない\n  if (wholeResult.length === 0) {\n    return [\n      {\n        ブロック: null,\n        rest: 手牌,\n        children: [],\n      },\n    ]\n  }\n\n  return wholeResult\n}\n\nexport const flatTree = <T extends TブロックType>(\n  tree: IntermediateExtractTree<T>,\n): IntermediateExtractResult<T>[] => {\n  if (tree.children.length === 0) {\n    return [\n      {\n        ブロック: tree.ブロック ? [tree.ブロック] : [],\n        rest: tree.rest,\n      },\n    ]\n  }\n\n  const flatChildren = tree.children.flatMap(flatTree)\n\n  const result = flatChildren.map((c) => ({\n    ブロック: (tree.ブロック ? [tree.ブロック, ...c.ブロック] : [...c.ブロック]).sort((a, b) => {\n      if (a == null) return 1\n      if (b == null) return -1\n      // component は、suit が m > p > s > z の順、そして数字が小さい順\n      if (a.type === b.type) {\n        if (a.component[0].suit === b.component[0].suit) {\n          return a.component[0].number - b.component[0].number\n        }\n        return a.component[0].suit.charCodeAt(0) - b.component[0].suit.charCodeAt(0)\n      }\n      // type は、雀頭 > 面子 > 塔子 の順\n      if (a.type === \"雀頭\") return -1\n      if (b.type === \"雀頭\") return 1\n      if (a.type === \"面子\") return -1\n      if (b.type === \"面子\") return 1\n      if (a.type === \"塔子\") return -1\n      if (b.type === \"塔子\") return 1\n      return 0\n    }),\n    rest: c.rest,\n  }))\n\n  return result\n}\n\nexport const flatTrees = <T extends TブロックType>(\n  trees: IntermediateExtractTree<T>[],\n): IntermediateExtractResult<T>[] => {\n  return trees.flatMap(flatTree).filter((r, i, arr) => {\n    const rStr = JSON.stringify(r)\n    return arr.findIndex((r2) => JSON.stringify(r2) === rStr) === i\n  })\n}\n","import { 牌 } from \"../牌.mjs\"\nimport { calcシャンテン数5ブロック } from \"./calcシャンテン数.mjs\"\nimport { extractSingleブロック } from \"./extractSingleブロック.mjs\"\nimport { extract塔子Tree, extract面子Tree, flatTrees } from \"./extractブロックTree.mjs\"\nimport {\n  ExtractResult5ブロック,\n  IntermediateExtractResult,\n  Result単体抽出,\n  Result単体抽出Success,\n  Tブロック,\n  T手牌Suit別,\n} from \"./手牌utils.type.mjs\"\n\nexport const extractPriority雀頭 = (手牌: T手牌Suit別): ExtractResult5ブロック[] => {\n  const results: ExtractResult5ブロック[] = []\n  const 雀頭List = extract雀頭(手牌)\n\n  // ブロック(面子・塔子)を抽出する\n  for (const 雀頭 of 雀頭List) {\n    const 面子List = flatTrees(extract面子Tree(雀頭.rest))\n    if (面子List.length > 0) {\n      for (const 面子 of 面子List) {\n        const 塔子List = flatTrees(extract塔子Tree(面子.rest))\n        for (const 塔子 of 塔子List) {\n          const _塔子 = exclude塔子sameAs雀頭(雀頭.ブロック, 塔子)\n          results.push({\n            雀頭: 雀頭.ブロック,\n            面子: 面子.ブロック,\n            塔子: _塔子.ブロック,\n            rest: _塔子.rest,\n          })\n        }\n      }\n    } else {\n      const 塔子List = flatTrees(extract塔子Tree(雀頭.rest))\n      // 塔子がとれなくても、restだけを含んだ配列が返ってくるので、これで動く\n      for (const 塔子 of 塔子List) {\n        const _塔子 = exclude塔子sameAs雀頭(雀頭.ブロック, 塔子)\n        // const _塔子 = 塔子\n        results.push({\n          雀頭: 雀頭.ブロック,\n          面子: [],\n          塔子: _塔子.ブロック,\n          rest: _塔子.rest,\n        })\n      }\n    }\n  }\n\n  // シャンテン数の低いもののみを残す\n  const シャンテン数付きresult: [number, ExtractResult5ブロック][] = results.map((r) => [\n    calcシャンテン数5ブロック(r),\n    r,\n  ])\n\n  const min = Math.min(...シャンテン数付きresult.map(([s]) => s))\n  const filteredResults = シャンテン数付きresult\n    .filter(([シャンテン数]) => シャンテン数 === min)\n    .map(([, r]) => r)\n\n  return filteredResults\n}\n\nconst exclude塔子sameAs雀頭 = (\n  雀頭: Tブロック<\"雀頭\">,\n  塔子: IntermediateExtractResult<\"塔子\">,\n): IntermediateExtractResult<\"塔子\"> => {\n  const result: IntermediateExtractResult<\"塔子\"> = {\n    ブロック: [],\n    rest: {\n      m: 塔子.rest.m.map((p) => p.clone()),\n      p: 塔子.rest.p.map((p) => p.clone()),\n      s: 塔子.rest.s.map((p) => p.clone()),\n      z: 塔子.rest.z.map((p) => p.clone()),\n    },\n  }\n  for (const 塔子ブロック of 塔子.ブロック) {\n    // 対子が雀頭と同じ場合は、restに入れる\n    const [p1, p2] = 塔子ブロック.component\n    if (p1.toEqual(p2) && p1.toEqual(雀頭.component[0])) {\n      result.rest[p1.suit].push(p1)\n      result.rest[p2.suit].push(p2)\n    } else {\n      result.ブロック.push(塔子ブロック)\n    }\n  }\n  return result\n}\n\nconst extract雀頭 = (手牌: T手牌Suit別): Result単体抽出Success<\"雀頭\">[] => {\n  const wholeResult: Result単体抽出<\"雀頭\">[] = []\n  for (const suit of [\"m\", \"p\", \"s\", \"z\"] as const) {\n    const 手牌suit = 手牌[suit]\n    for (let i = 0; i < 手牌suit.length; i++) {\n      wholeResult.push(extractSingleブロック(手牌, \"雀頭\", { suit: suit, index: i }))\n    }\n  }\n  // failureを除外\n  const successResult = wholeResult.filter(\n    (r) => r.status === \"success\",\n  ) as Result単体抽出Success<\"雀頭\">[]\n  // 重複除去\n  const uniqueResult = successResult.filter((r, i) => {\n    const rStr = JSON.stringify(r)\n    return successResult.findIndex((r2) => JSON.stringify(r2) === rStr) === i\n  })\n  return uniqueResult\n}\n\nif (import.meta.vitest) {\n  test(\"雀頭抽出\", () => {\n    const result = extract雀頭({\n      m: ([\"1m\", \"1m\", \"1m\", \"2m\", \"3m\"] as const).map((s) => new 牌(s)),\n      p: ([\"4p\", \"5p\", \"6p\", \"6p\", \"9p\"] as const).map((s) => new 牌(s)),\n      s: ([\"3s\"] as const).map((s) => new 牌(s)),\n      z: ([\"1z\", \"1z\"] as const).map((s) => new 牌(s)),\n    })\n    expect(result).toMatchSnapshot()\n  })\n}\n","import { 牌 } from \"../牌.mjs\"\nimport { calcシャンテン数5ブロック } from \"./calcシャンテン数.mjs\"\nimport { extract塔子Tree, extract面子Tree, flatTrees } from \"./extractブロックTree.mjs\"\nimport { ExtractResult5ブロック, T手牌Suit別 } from \"./手牌utils.type.mjs\"\n\nexport const extractPriority面子 = (手牌: T手牌Suit別): ExtractResult5ブロック[] => {\n  const results: ExtractResult5ブロック[] = []\n  const 面子List = flatTrees(extract面子Tree(手牌))\n\n  if (面子List.length > 0) {\n    // ブロック(面子・塔子)を抽出する\n    for (const 面子 of 面子List) {\n      const 塔子List = flatTrees(extract塔子Tree(面子.rest))\n      for (const 塔子 of 塔子List) {\n        results.push({\n          雀頭: null,\n          面子: 面子.ブロック,\n          塔子: 塔子.ブロック,\n          rest: 塔子.rest,\n        })\n      }\n    }\n  } else {\n    const 塔子List = flatTrees(extract塔子Tree(手牌))\n    // 塔子がとれなくても、restだけを含んだ配列が返ってくるので、これで動く\n    for (const 塔子 of 塔子List) {\n      results.push({\n        雀頭: null,\n        面子: [],\n        塔子: 塔子.ブロック,\n        rest: 塔子.rest,\n      })\n    }\n  }\n\n  // 雀頭がなく、塔子として対子が抽出された場合、それは本来雀頭として抽出されるべきもの\n  // extractPriority雀頭で抽出してあるので、この関数の結果からは除外する\n  const filteredResults = results.filter((r) => !r.塔子.some((t) => is対子(...t.component)))\n\n  // シャンテン数の低いもののみを残す\n  const シャンテン数付きresult: [number, ExtractResult5ブロック][] = filteredResults.map((r) => [\n    calcシャンテン数5ブロック(r),\n    r,\n  ])\n  const min = Math.min(...シャンテン数付きresult.map(([s]) => s))\n  const filteredResults2 = シャンテン数付きresult\n    .filter(([シャンテン数]) => シャンテン数 === min)\n    .map(([, r]) => r)\n\n  return filteredResults2\n}\n\nconst is対子 = (牌1: 牌, 牌2: 牌): boolean => {\n  return 牌1.toEqual(牌2)\n}\n","import { generate手牌Suit別ForTest } from \"../utils/utils.mjs\"\nimport { extract対子Tree, flatTrees } from \"./extractブロックTree.mjs\"\nimport {\n  ExtractResult5ブロック,\n  ExtractResult七対子,\n  ExtractResult国士無双,\n  T手牌Suit別,\n} from \"./手牌utils.type.mjs\"\n\nexport const extract七対子 = (手牌: T手牌Suit別): ExtractResult七対子 => {\n  const 七対子 = flatTrees(extract対子Tree(手牌))[0]\n  if (七対子 === undefined) {\n    return {\n      対子: [],\n      rest: 手牌,\n    }\n  }\n  // ブロック内にまったく同一の対子がある場合は、片方をrestに書き戻す\n  // 七対子.ブロックから重複している対子のインデックスを探す。ひとつだけでよい\n  // あれば、その対子をrestに書き戻す\n  const duplicatedIndex = 七対子.ブロック.findIndex((対子, index, array) => {\n    return (\n      array.findIndex((対子2) => {\n        return 対子.component[0].toString() === 対子2.component[0].toString()\n      }) !== index\n    )\n  })\n  if (duplicatedIndex !== -1) {\n    const duplicated対子 = 七対子.ブロック[duplicatedIndex]\n    if (duplicated対子 === undefined) throw new Error(\"duplicated対子 is undefined\")\n    七対子.ブロック.splice(duplicatedIndex, 1)\n    七対子.rest[duplicated対子.component[0].suit].push(duplicated対子.component[0])\n    七対子.rest[duplicated対子.component[1].suit].push(duplicated対子.component[1])\n  }\n\n  return {\n    対子: 七対子.ブロック,\n    rest: 七対子.rest,\n  }\n}\n\nexport const extract国士無双 = (手牌: T手牌Suit別): ExtractResult国士無双 => {\n  const 么九牌unique: ExtractResult国士無双[\"么九牌unique\"] = []\n  const 么九牌rest: ExtractResult国士無双[\"么九牌rest\"] = []\n  const rest: ExtractResult国士無双[\"rest\"] = {\n    m: [],\n    p: [],\n    s: [],\n    z: [],\n  }\n  // m,p,sから1,9の牌を1枚ずつだけ抽出する\n  for (const suit of [\"m\", \"p\", \"s\"] as const) {\n    for (const 牌 of 手牌[suit]) {\n      if (牌.number === 1 || 牌.number === 9) {\n        if (!么九牌unique.find((p) => p.toString() === 牌.toString())) {\n          么九牌unique.push(牌)\n        } else {\n          么九牌rest.push(牌)\n        }\n      } else {\n        rest[suit].push(牌)\n      }\n    }\n  }\n  // zはすべての種類を1枚ずつだけ抽出する\n  for (const 牌 of 手牌.z) {\n    if (!么九牌unique.find((p) => p.toString() === 牌.toString())) {\n      么九牌unique.push(牌)\n    } else {\n      么九牌rest.push(牌)\n    }\n  }\n  return {\n    么九牌unique,\n    么九牌rest,\n    rest,\n  }\n}\n","import { Str牌 } from \"../../utils/types.mjs\"\nimport { 牌 } from \"../../牌.mjs\"\n\nexport const countRemaining牌num = (\n  target: 牌[],\n  visible牌List: 牌[],\n): Map<Str牌, { 牌: 牌; remains: number }> => {\n  const map = new Map<Str牌, { 牌: 牌; remains: number }>(\n    target.map((p) => [p.toString(), { 牌: p, remains: 4 }]),\n  )\n  for (const visible牌 of visible牌List) {\n    const p = map.get(visible牌.toString())\n    if (p) {\n      p.remains -= 1\n    }\n  }\n  return map\n}\n\nif (import.meta.vitest) {\n  test(\"全枯れ\", () => {\n    const result = countRemaining牌num(\n      [new 牌(\"1m\")],\n      [new 牌(\"1m\"), new 牌(\"1m\"), new 牌(\"1m\"), new 牌(\"1m\")],\n    )\n    expect(result.get(\"1m\")).toEqual({ 牌: new 牌(\"1m\"), remains: 0 })\n  })\n}\n","import { 牌 } from \"../../牌.mjs\"\n\nexport const sort牌List = (target: 牌[]): 牌[] => {\n  return target.sort((a, b) => {\n    if (a.suit === b.suit) return a.number - b.number\n    return a.suit.charCodeAt(0) - b.suit.charCodeAt(0)\n  })\n}\n\nexport const unique牌List = (target: 牌[]): 牌[] => {\n  // 重複除去\n  return sort牌List(target).filter((p, i, arr) => {\n    if (i === 0) return true\n\n    const prev = arr[i - 1]\n    if (prev === undefined) throw new Error(\"arr[i-1] is undefined\")\n    return !p.toEqual(prev)\n  })\n}\n","import { Str牌 } from \"../utils/types.mjs\"\nimport { 牌 } from \"../牌.mjs\"\nimport {\n  calcシャンテン数5ブロック,\n  calcシャンテン数七対子,\n  calcシャンテン数国士無双,\n} from \"./calcシャンテン数.mjs\"\nimport { extractPriority雀頭 } from \"./extractPriority雀頭.mjs\"\nimport { extractPriority面子 } from \"./extractPriority面子.mjs\"\nimport { extract七対子, extract国士無双 } from \"./extract特殊役.mjs\"\nimport { seek有効牌5ブロック, seek有効牌七対子, seek有効牌国士無双 } from \"./seek有効牌.mjs\"\nimport { countRemaining牌num } from \"./utils/countRemaining牌.mjs\"\nimport { unique牌List } from \"./utils/format牌List.mjs\"\nimport { ExtractResult5ブロック, T手牌Suit別 } from \"./手牌utils.type.mjs\"\n\nconst analyze手牌13Memo = new Map<string, AnalysisResult手牌13>()\nconst addToMap = (key: string, value: AnalysisResult手牌13) => {\n  analyze手牌13Memo.set(key, value)\n  // Map が 3つを超えたら、古いものを削除する\n  if (analyze手牌13Memo.size > 3) {\n    const keys = Array.from(analyze手牌13Memo.keys())\n    if (keys[0]) {\n      analyze手牌13Memo.delete(keys[0])\n    }\n  }\n}\n\ntype AnalysisResult13Common = {\n  シャンテン数: number\n  有効牌: 牌[]\n}\n\ntype AnalysisResult5ブロックIndivisual = {\n  シャンテン数: number\n  ブロック: ExtractResult5ブロック\n  有効牌: 牌[]\n}\n\nexport type AnalysisResult手牌13 = {\n  _5ブロック: AnalysisResult13Common & {\n    indivisuals: AnalysisResult5ブロックIndivisual[]\n  }\n  七対子: AnalysisResult13Common\n  国士無双: AnalysisResult13Common\n}\n\nexport type AnalysisResult13 = {\n  analysisResult: AnalysisResult手牌13\n  シャンテン数: number\n  有効牌: 牌[]\n  remaining有効牌num: Map<\n    Str牌,\n    {\n      牌: 牌\n      remains: number\n    }\n  >\n}\n\n// 集約関数\nexport const analyze13 = (手牌Suit別: T手牌Suit別, used牌: 牌[]): AnalysisResult13 => {\n  const analysisResult = analyze手牌13(手牌Suit別)\n\n  const シャンテン数 = Math.min(\n    analysisResult._5ブロック.シャンテン数,\n    analysisResult.七対子.シャンテン数,\n    analysisResult.国士無双.シャンテン数,\n  )\n\n  const 有効牌target = []\n  if (シャンテン数 === analysisResult._5ブロック.シャンテン数) {\n    有効牌target.push(...analysisResult._5ブロック.有効牌)\n  }\n  if (シャンテン数 === analysisResult.七対子.シャンテン数) {\n    有効牌target.push(...analysisResult.七対子.有効牌)\n  }\n  if (シャンテン数 === analysisResult.国士無双.シャンテン数) {\n    有効牌target.push(...analysisResult.国士無双.有効牌)\n  }\n  const 有効牌 = unique牌List(有効牌target)\n\n  const remaining有効牌num = countRemaining牌num(有効牌, used牌)\n\n  return {\n    analysisResult,\n    シャンテン数,\n    有効牌,\n    remaining有効牌num,\n  }\n}\n\n// 手牌をブロックに分けて待ちを求める\nconst analyze手牌13 = (手牌Suit別: T手牌Suit別): AnalysisResult手牌13 => {\n  // メモ化する\n  const key =\n    手牌Suit別.m.map((p) => p.toString()).join(\"\") +\n    手牌Suit別.p.map((p) => p.toString()).join(\"\") +\n    手牌Suit別.s.map((p) => p.toString()).join(\"\") +\n    手牌Suit別.z.map((p) => p.toString()).join(\"\")\n\n  const memo = analyze手牌13Memo.get(key)\n  if (memo) {\n    return memo\n  }\n\n  const result = {\n    _5ブロック: analyze手牌5ブロック(手牌Suit別),\n    七対子: analyze手牌七対子(手牌Suit別),\n    国士無双: analyze手牌国士無双(手牌Suit別),\n  }\n  addToMap(key, result)\n\n  return result\n}\n\nconst analyze手牌5ブロック = (手牌Suit別: T手牌Suit別): AnalysisResult手牌13[\"_5ブロック\"] => {\n  const priority雀頭 = extractPriority雀頭(手牌Suit別)\n  const priority面子 = extractPriority面子(手牌Suit別)\n  // シャンテン数の最も低いものを抽出する\n  const _シャンテン数5ブロック =\n    priority雀頭.length + priority面子.length === 0\n      ? 8\n      : Math.min(...[...priority雀頭, ...priority面子].map((r) => calcシャンテン数5ブロック(r)))\n\n  const _5ブロック = [...priority雀頭, ...priority面子].filter(\n    (r) => calcシャンテン数5ブロック(r) === _シャンテン数5ブロック,\n  )\n\n  const indivisuals5ブロック = _5ブロック.map((b) => ({\n    シャンテン数: _シャンテン数5ブロック,\n    ブロック: b,\n    有効牌: seek有効牌5ブロック(b, _シャンテン数5ブロック),\n  }))\n\n  // 有効牌を集約して、重複を除去する\n  const 有効牌5ブロック = indivisuals5ブロック\n    .flatMap((r) => r.有効牌)\n    .filter((p, i, arr) => {\n      return arr.findIndex((p2) => p2.suit === p.suit && p2.number === p.number) === i\n    })\n    .sort((a, b) => {\n      if (a.suit === b.suit) return a.number - b.number\n      return a.suit.charCodeAt(0) - b.suit.charCodeAt(0)\n    })\n\n  return {\n    シャンテン数: _シャンテン数5ブロック,\n    有効牌: 有効牌5ブロック,\n    indivisuals: indivisuals5ブロック,\n  }\n}\n\nconst analyze手牌七対子 = (手牌Suit別: T手牌Suit別): AnalysisResult手牌13[\"七対子\"] => {\n  const 七対子 = extract七対子(手牌Suit別)\n  const _シャンテン数七対子 = calcシャンテン数七対子(七対子)\n  const 有効牌七対子 = seek有効牌七対子(七対子)\n  return {\n    シャンテン数: _シャンテン数七対子,\n    有効牌: 有効牌七対子,\n  }\n}\n\nconst analyze手牌国士無双 = (手牌Suit別: T手牌Suit別): AnalysisResult手牌13[\"国士無双\"] => {\n  const 国士無双 = extract国士無双(手牌Suit別)\n  const _シャンテン数国士無双 = calcシャンテン数国士無双(国士無双)\n  const 有効牌国士無双 = seek有効牌国士無双(国士無双)\n  return {\n    シャンテン数: _シャンテン数国士無双,\n    有効牌: 有効牌国士無双,\n  }\n}\n","import { Str牌 } from \"./utils/types.mjs\"\nimport { 副露 } from \"./副露.mjs\"\nimport { AnalysisResult13, analyze13 } from \"./手牌utils/analyze手牌.mjs\"\nimport { sort牌List, unique牌List } from \"./手牌utils/utils/format牌List.mjs\"\nimport { T手牌Suit別 } from \"./手牌utils/手牌utils.type.mjs\"\nimport { 牌 } from \"./牌.mjs\"\n\nexport type T手牌普通 =\n  | [牌]\n  | [牌, 牌, 牌, 牌]\n  | [牌, 牌, 牌, 牌, 牌, 牌, 牌]\n  | [牌, 牌, 牌, 牌, 牌, 牌, 牌, 牌, 牌, 牌]\n  | [牌, 牌, 牌, 牌, 牌, 牌, 牌, 牌, 牌, 牌, 牌, 牌, 牌]\ntype T手牌副露 = [] | [副露] | [副露, 副露] | [副露, 副露, 副露] | [副露, 副露, 副露, 副露]\ntype analysisResult14 = Map<\n  Str牌,\n  {\n    打牌: 牌\n    analysisResult: AnalysisResult13\n  }\n>\n\n/**\n * Represents 手牌.\n */\nexport class 手牌 {\n  普通: T手牌普通\n  副露: T手牌副露 = []\n  ツモ: 牌 | null = null\n  protected analysisResult13: AnalysisResult13 | null = null\n  protected analysisResult14: analysisResult14 | null = null\n\n  /**\n   * Creates a new 手牌 instance.\n   * @param 普通 The normal 牌s in the hand.\n   * @param 副露 The melded 牌s in the hand.\n   */\n  constructor(普通: T手牌普通, 副露?: T手牌副露) {\n    this.普通 = 普通\n    if (副露) {\n      this.副露 = 副露\n    }\n    this.sort()\n    this.analyze13()\n  }\n\n  /**\n   * Sorts the normal 牌s in the hand.\n   */\n  protected sort() {\n    this.普通.sort((a, b) => {\n      if (a.suit === b.suit) return a.number - b.number\n      return a.suit.charCodeAt(0) - b.suit.charCodeAt(0)\n    })\n  }\n\n  /**\n   * Returns the 手牌's マンズ 牌s.\n   * @returns The マンズ 牌s in the hand.\n   */\n  protected マンズ() {\n    return this.普通.filter((p) => p.suit === \"m\")\n  }\n\n  /**\n   * Returns the 手牌's ピンズ 牌s.\n   * @returns The ピンズ 牌s in the hand.\n   */\n  protected ピンズ() {\n    return this.普通.filter((p) => p.suit === \"p\")\n  }\n\n  /**\n   * Returns the 手牌's ソーズ 牌s.\n   * @returns The ソーズ 牌s in the hand.\n   */\n  protected ソーズ() {\n    return this.普通.filter((p) => p.suit === \"s\")\n  }\n\n  /**\n   * Returns the 手牌's 字牌 牌s.\n   * @returns The 字牌 牌s in the hand.\n   */\n  protected 字牌() {\n    return this.普通.filter((p) => p.suit === \"z\")\n  }\n\n  /**\n   * Returns a string representation of the normal 牌s in the hand.\n   * @returns A string representation of the normal 牌s.\n   */\n  toString普通() {\n    return this.普通.map((p) => p.toString()).join(\"\")\n  }\n\n  /**\n   * Sets the ツモ 牌 in the hand and performs analysis for 14-牌 hand.\n   * @param ツモ The ツモ 牌.\n   */\n  doツモ(ツモ: 牌) {\n    this.ツモ = ツモ\n    this.analyze14()\n  }\n\n  /**\n   * Adds an melded set of 牌s to the hand and performs analysis for 14-牌 hand.\n   * @param 副露 The melded set of 牌s.\n   */\n  do副露(副露: 副露) {\n    if (this.副露.length === 4) throw new Error(\"副露できるのは4回まで\")\n    // 副露.ほかの牌 が 手牌に含まれていないといけない\n    for (const p of 副露.other牌) {\n      if (p === undefined) throw new Error(\"副露のほかの牌に undefined が含まれている\")\n      if (!this.普通.some((p2) => p2.toEqual(p))) {\n        throw new Error(`手牌に ${p} がないのに副露しようとした`)\n      }\n    }\n\n    this.副露 = [...this.副露, 副露]\n    // 副露で使った牌を手牌から削除する\n    for (const p of 副露.other牌) {\n      if (p === undefined) throw new Error(\"副露のほかの牌に undefined が含まれている\")\n      const index = this.普通.findIndex((p2) => p2.toEqual(p))\n      this.普通.splice(index, 1)\n    }\n    this.analyze14({ is副露後: true })\n  }\n\n  /**\n   * Performs the specified 打牌 action in the hand.\n   * @param 打牌 The 打牌 action to perform.\n   */\n  do打牌(\n    打牌:\n      | { type: \"ツモ切り\" }\n      | { type: \"ツモ後手出し\"; 牌: 牌 }\n      | { type: \"副露後手出し\"; 牌: 牌 },\n  ): void {\n    switch (打牌.type) {\n      case \"ツモ切り\": {\n        if (this.ツモ === null) throw new Error(\"ツモしていないのに打牌しようとした\")\n        this.ツモ = null\n        break\n      }\n      case \"ツモ後手出し\": {\n        if (this.ツモ === null) throw new Error(\"ツモしていないのに打牌しようとした\")\n        const index = this.普通.findIndex((p) => p.toEqual(打牌.牌))\n        if (index === -1) throw new Error(`手牌に ${打牌.牌} がないのに打牌しようとした`)\n        this.普通.splice(index, 1, this.ツモ)\n        this.ツモ = null\n        this.sort()\n        break\n      }\n      case \"副露後手出し\": {\n        const index = this.普通.findIndex((p) => p.toEqual(打牌.牌))\n        if (index === -1) throw new Error(`手牌に ${打牌.牌} がないのに打牌しようとした`)\n        this.普通.splice(index, 1)\n        this.ツモ = null\n        this.sort()\n        break\n      }\n      default: {\n        throw new Error(`invalid 打牌.type: ${打牌}`)\n      }\n    }\n    this.analyze13()\n  }\n\n  /**\n   * Returns the analysis result for 13-牌 hand.\n   * @returns The analysis result for 13-牌 hand.\n   */\n  getAnalysisResult13() {\n    return this.analysisResult13\n  }\n\n  /**\n   * Returns the analysis result for 14-牌 hand.\n   * @returns The analysis result for 14-牌 hand.\n   */\n  getAnalysisResult14() {\n    return this.analysisResult14\n  }\n\n  /**\n   * Returns a list of all 牌s in the hand, including normal and melded 牌s.\n   * @returns A list of all 牌s in the hand.\n   */\n  牌List() {\n    const _牌List = [...this.普通, ...this.副露.flatMap((f) => f.to牌List())]\n    if (this.ツモ) _牌List.push(this.ツモ)\n\n    return sort牌List(_牌List)\n  }\n\n  /**\n   * Returns a list of all 牌s in the hand, excluding the ツモ 牌.\n   * @returns A list of all 牌s in the hand, excluding the ツモ 牌.\n   */\n  牌ListExcludesツモ() {\n    const _牌List = [...this.普通, ...this.副露.flatMap((f) => f.to牌List())]\n\n    return sort牌List(_牌List)\n  }\n\n  /**\n   * Performs analysis for 13-牌 hand.\n   * @returns The analysis result for 13-牌 hand.\n   */\n  protected analyze13() {\n    const analysisResult = analyze13(\n      {\n        m: this.マンズ(),\n        p: this.ピンズ(),\n        s: this.ソーズ(),\n        z: this.字牌(),\n      },\n      this.牌List(),\n    )\n    this.analysisResult14 = null\n    this.analysisResult13 = analysisResult\n    return this.analysisResult13\n  }\n\n  /**\n   * Performs analysis for 14-牌 hand.\n   * @param is副露後 Indicates whether the analysis is performed after an melded set of 牌s is added.\n   * @returns The analysis result for 14-牌 hand.\n   */\n  protected analyze14({ is副露後 } = { is副露後: false }): analysisResult14 {\n    const hand = (() => {\n      if (is副露後) return this.普通\n      if (this.ツモ === null) throw new Error(\"ツモしていないのに analyze14 しようとした\")\n      return sort牌List([...this.普通, this.ツモ])\n    })()\n    const 打牌candidateList = unique牌List(hand)\n    const result: analysisResult14 = new Map()\n    // 打牌candidateList をループする\n    for (const 牌 of 打牌candidateList) {\n      const i = hand.findIndex((p) => p.toEqual(牌))\n      result.set(牌.toString(), {\n        打牌: 牌,\n        analysisResult: analyze13(牌ListToSuit別(hand.toSpliced(i, 1)), this.牌List()),\n      })\n    }\n    this.analysisResult13 = null\n    this.analysisResult14 = result\n    return this.analysisResult14\n  }\n}\n\nconst 牌ListToSuit別 = (牌List: 牌[]): T手牌Suit別 => {\n  const 手牌Suit別: T手牌Suit別 = {\n    m: [],\n    p: [],\n    s: [],\n    z: [],\n  }\n  for (const 牌 of 牌List) {\n    手牌Suit別[牌.suit].push(牌)\n  }\n  return 手牌Suit別\n}\n"],"mappings":"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","names":["副露","call","called牌","other牌","from","牌","_牌","pai","isRed","suit","number","parsePaiString","numberErrorMessage","numberErrorMessage数牌","numberErrorMessage字牌","isStr牌","str","whole牌List","牌","countRequiredブロックnum","count牌","count牌","extractResult5ブロック","count","flattenRest","is暗刻","面子","seek有効牌5ブロック","extractResult","シャンテン数","seek有効牌5ブロックテンパイ","seek有効牌5ブロックノーテン","seek有効牌七対子","result","rest","flattenRest","対子","p","seek有効牌国士無双","target","s","牌","p2","seek塔子To面子","牌str","required面子塔子num","countRequiredブロックnum","count牌","面子塔子数","塔子","restList","seekRestTo塔子","暗刻List","extract暗刻List","isSameAs雀頭Or暗刻","whole牌List","暗刻","r","i","a","b","牌1","牌2","isStr牌","牌str1","牌str2","浮き牌","雀頭","面子List","n","index","min","max","str","m","is暗刻","calcシャンテン数5ブロック","extractResult5ブロック","requiredブロックnum","countRequiredブロックnum","count牌","required面子num","雀頭","面子","塔子","_rest","rest","flattenRest","シャンテン数","tanki","is暗刻","calcシャンテン数七対子","extractResult七対子","result","uniqueFlattenRest","p","index","array","p2","対子","calcシャンテン数国士無双","extractResult国士無双","extractSingleブロック","手牌","type","startAt","validate手牌","suit","index","牌1","牌2","is対子","_","i","牌3","is刻子","find順子","find順塔子","p","find順子","手牌","startAt","手牌suit","start牌","牌2str","牌3str","isStr牌","順子","牌","牌2index","p","牌3index","_","i","find順塔子","extract面子Tree","手牌","wholeResult","suit","手牌suit","i","result面子","extractSingleブロック","children","extract塔子Tree","result塔子","extract対子Tree","result対子","flatTree","tree","c","a","b","flatTrees","trees","r","arr","rStr","r2","extractPriority雀頭","手牌","results","雀頭List","extract雀頭","雀頭","面子List","flatTrees","extract面子Tree","面子","塔子List","extract塔子Tree","塔子","_塔子","exclude塔子sameAs雀頭","シャンテン数付きresult","r","calcシャンテン数5ブロック","min","s","シャンテン数","result","p","塔子ブロック","p1","p2","wholeResult","suit","手牌suit","i","extractSingleブロック","successResult","rStr","r2","牌","extractPriority面子","手牌","results","面子List","flatTrees","extract面子Tree","面子","塔子List","extract塔子Tree","塔子","シャンテン数付きresult","r","t","is対子","calcシャンテン数5ブロック","min","s","シャンテン数","牌1","牌2","extract七対子","手牌","七対子","flatTrees","extract対子Tree","duplicatedIndex","対子","index","array","対子2","duplicated対子","extract国士無双","么九牌unique","么九牌rest","rest","suit","牌","p","countRemaining牌num","target","visible牌List","map","p","visible牌","result","牌","sort牌List","target","a","b","unique牌List","p","i","arr","prev","analyze手牌13Memo","addToMap","key","value","keys","analyze13","手牌Suit別","used牌","analysisResult","analyze手牌13","シャンテン数","有効牌target","有効牌","unique牌List","remaining有効牌num","countRemaining牌num","p","memo","result","analyze手牌5ブロック","analyze手牌七対子","analyze手牌国士無双","priority雀頭","extractPriority雀頭","priority面子","extractPriority面子","_シャンテン数5ブロック","r","calcシャンテン数5ブロック","indivisuals5ブロック","b","seek有効牌5ブロック","有効牌5ブロック","i","arr","p2","a","七対子","extract七対子","_シャンテン数七対子","calcシャンテン数七対子","有効牌七対子","seek有効牌七対子","国士無双","extract国士無双","_シャンテン数国士無双","calcシャンテン数国士無双","有効牌国士無双","seek有効牌国士無双","手牌","普通","副露","a","b","p","ツモ","p2","index","打牌","_牌List","f","sort牌List","analysisResult","analyze13","is副露後","hand","打牌candidateList","unique牌List","result","牌","i","牌ListToSuit別","牌List","手牌Suit別"]}